/* automatically generated by rust-bindgen */

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(improper_ctypes)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type UINT32 = ::std::os::raw::c_uint;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type BOOL = ::std::os::raw::c_int;
pub type VOID = ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeHypervisorPresent: WHV_CAPABILITY_CODE = 0;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeFeatures: WHV_CAPABILITY_CODE = 1;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExtendedVmExits: WHV_CAPABILITY_CODE = 2;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExceptionExitBitmap: WHV_CAPABILITY_CODE = 3;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorVendor: WHV_CAPABILITY_CODE = 4096;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorFeatures: WHV_CAPABILITY_CODE = 4097;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorClFlushSize: WHV_CAPABILITY_CODE = 4098;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorXsaveFeatures: WHV_CAPABILITY_CODE = 4099;
pub type WHV_CAPABILITY_CODE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY_FEATURES {
    pub __bindgen_anon_1: WHV_CAPABILITY_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn PartialUnmap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PartialUnmap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LocalApicEmulation(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocalApicEmulation(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xsave(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xsave(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPageTracking(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DirtyPageTracking(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculationControl(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SpeculationControl(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PartialUnmap: UINT64,
        LocalApicEmulation: UINT64,
        Xsave: UINT64,
        DirtyPageTracking: UINT64,
        SpeculationControl: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PartialUnmap: u64 = unsafe { ::std::mem::transmute(PartialUnmap) };
            PartialUnmap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LocalApicEmulation: u64 = unsafe { ::std::mem::transmute(LocalApicEmulation) };
            LocalApicEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Xsave: u64 = unsafe { ::std::mem::transmute(Xsave) };
            Xsave as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DirtyPageTracking: u64 = unsafe { ::std::mem::transmute(DirtyPageTracking) };
            DirtyPageTracking as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SpeculationControl: u64 = unsafe { ::std::mem::transmute(SpeculationControl) };
            SpeculationControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_EXTENDED_VM_EXITS {
    pub __bindgen_anon_1: WHV_EXTENDED_VM_EXITS__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1)
        )
    );
}
impl WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    #[inline]
    pub fn X64CpuidExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64CpuidExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64MsrExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64MsrExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExceptionExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        X64CpuidExit: UINT64,
        X64MsrExit: UINT64,
        ExceptionExit: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let X64CpuidExit: u64 = unsafe { ::std::mem::transmute(X64CpuidExit) };
            X64CpuidExit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let X64MsrExit: u64 = unsafe { ::std::mem::transmute(X64MsrExit) };
            X64MsrExit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExceptionExit: u64 = unsafe { ::std::mem::transmute(ExceptionExit) };
            ExceptionExit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EXTENDED_VM_EXITS>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EXTENDED_VM_EXITS),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorAmd: WHV_PROCESSOR_VENDOR = 0;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorIntel: WHV_PROCESSOR_VENDOR = 1;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorHygon: WHV_PROCESSOR_VENDOR = 2;
pub type WHV_PROCESSOR_VENDOR = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PROCESSOR_FEATURES {
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn Sse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LahfSahfSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LahfSahfSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ssse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Ssse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4aSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4aSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XopSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XopSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PopCntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PopCntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cmpxchg16bSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Cmpxchg16bSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Altmovcr8Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Altmovcr8Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LzcntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LzcntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MisAlignSseSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MisAlignSseSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MmxExtSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MmxExtSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Amd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Amd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAmd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedAmd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Page1GbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Page1GbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Fma4Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Fma4Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn F16CSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_F16CSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdRandSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdRandSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdWrFsGsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdWrFsGsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmepSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmepSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnhancedFastStringSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnhancedFastStringSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MovbeSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MovbeSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Npiep1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Npiep1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DepX87FPUSaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DepX87FPUSaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdSeedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdSeedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AdxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IntelPrefetchSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IntelPrefetchSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmapSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmapSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HleSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HleSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtmSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RtmSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdtscpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdtscpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClflushoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClflushoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClwbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClwbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ShaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X87PointersSavedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X87PointersSavedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InvpcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InvpcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StibpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StibpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbpbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbpbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbdSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbdSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FastShortRepMovSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FastShortRepMovSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdclNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdclNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsAllSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsAllSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RsbANo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RsbANo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Sse3Support: UINT64,
        LahfSahfSupport: UINT64,
        Ssse3Support: UINT64,
        Sse4_1Support: UINT64,
        Sse4_2Support: UINT64,
        Sse4aSupport: UINT64,
        XopSupport: UINT64,
        PopCntSupport: UINT64,
        Cmpxchg16bSupport: UINT64,
        Altmovcr8Support: UINT64,
        LzcntSupport: UINT64,
        MisAlignSseSupport: UINT64,
        MmxExtSupport: UINT64,
        Amd3DNowSupport: UINT64,
        ExtendedAmd3DNowSupport: UINT64,
        Page1GbSupport: UINT64,
        AesSupport: UINT64,
        PclmulqdqSupport: UINT64,
        PcidSupport: UINT64,
        Fma4Support: UINT64,
        F16CSupport: UINT64,
        RdRandSupport: UINT64,
        RdWrFsGsSupport: UINT64,
        SmepSupport: UINT64,
        EnhancedFastStringSupport: UINT64,
        Bmi1Support: UINT64,
        Bmi2Support: UINT64,
        Reserved1: UINT64,
        MovbeSupport: UINT64,
        Npiep1Support: UINT64,
        DepX87FPUSaveSupport: UINT64,
        RdSeedSupport: UINT64,
        AdxSupport: UINT64,
        IntelPrefetchSupport: UINT64,
        SmapSupport: UINT64,
        HleSupport: UINT64,
        RtmSupport: UINT64,
        RdtscpSupport: UINT64,
        ClflushoptSupport: UINT64,
        ClwbSupport: UINT64,
        ShaSupport: UINT64,
        X87PointersSavedSupport: UINT64,
        InvpcidSupport: UINT64,
        IbrsSupport: UINT64,
        StibpSupport: UINT64,
        IbpbSupport: UINT64,
        Reserved2: UINT64,
        SsbdSupport: UINT64,
        FastShortRepMovSupport: UINT64,
        Reserved3: UINT64,
        RdclNo: UINT64,
        IbrsAllSupport: UINT64,
        Reserved4: UINT64,
        SsbNo: UINT64,
        RsbANo: UINT64,
        Reserved5: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Sse3Support: u64 = unsafe { ::std::mem::transmute(Sse3Support) };
            Sse3Support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LahfSahfSupport: u64 = unsafe { ::std::mem::transmute(LahfSahfSupport) };
            LahfSahfSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Ssse3Support: u64 = unsafe { ::std::mem::transmute(Ssse3Support) };
            Ssse3Support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Sse4_1Support: u64 = unsafe { ::std::mem::transmute(Sse4_1Support) };
            Sse4_1Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Sse4_2Support: u64 = unsafe { ::std::mem::transmute(Sse4_2Support) };
            Sse4_2Support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Sse4aSupport: u64 = unsafe { ::std::mem::transmute(Sse4aSupport) };
            Sse4aSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let XopSupport: u64 = unsafe { ::std::mem::transmute(XopSupport) };
            XopSupport as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PopCntSupport: u64 = unsafe { ::std::mem::transmute(PopCntSupport) };
            PopCntSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Cmpxchg16bSupport: u64 = unsafe { ::std::mem::transmute(Cmpxchg16bSupport) };
            Cmpxchg16bSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Altmovcr8Support: u64 = unsafe { ::std::mem::transmute(Altmovcr8Support) };
            Altmovcr8Support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LzcntSupport: u64 = unsafe { ::std::mem::transmute(LzcntSupport) };
            LzcntSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MisAlignSseSupport: u64 = unsafe { ::std::mem::transmute(MisAlignSseSupport) };
            MisAlignSseSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let MmxExtSupport: u64 = unsafe { ::std::mem::transmute(MmxExtSupport) };
            MmxExtSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Amd3DNowSupport: u64 = unsafe { ::std::mem::transmute(Amd3DNowSupport) };
            Amd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ExtendedAmd3DNowSupport: u64 =
                unsafe { ::std::mem::transmute(ExtendedAmd3DNowSupport) };
            ExtendedAmd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Page1GbSupport: u64 = unsafe { ::std::mem::transmute(Page1GbSupport) };
            Page1GbSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AesSupport: u64 = unsafe { ::std::mem::transmute(AesSupport) };
            AesSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let PclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(PclmulqdqSupport) };
            PclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PcidSupport: u64 = unsafe { ::std::mem::transmute(PcidSupport) };
            PcidSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Fma4Support: u64 = unsafe { ::std::mem::transmute(Fma4Support) };
            Fma4Support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let F16CSupport: u64 = unsafe { ::std::mem::transmute(F16CSupport) };
            F16CSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RdRandSupport: u64 = unsafe { ::std::mem::transmute(RdRandSupport) };
            RdRandSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let RdWrFsGsSupport: u64 = unsafe { ::std::mem::transmute(RdWrFsGsSupport) };
            RdWrFsGsSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SmepSupport: u64 = unsafe { ::std::mem::transmute(SmepSupport) };
            SmepSupport as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EnhancedFastStringSupport: u64 =
                unsafe { ::std::mem::transmute(EnhancedFastStringSupport) };
            EnhancedFastStringSupport as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let Bmi1Support: u64 = unsafe { ::std::mem::transmute(Bmi1Support) };
            Bmi1Support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Bmi2Support: u64 = unsafe { ::std::mem::transmute(Bmi2Support) };
            Bmi2Support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let MovbeSupport: u64 = unsafe { ::std::mem::transmute(MovbeSupport) };
            MovbeSupport as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Npiep1Support: u64 = unsafe { ::std::mem::transmute(Npiep1Support) };
            Npiep1Support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DepX87FPUSaveSupport: u64 = unsafe { ::std::mem::transmute(DepX87FPUSaveSupport) };
            DepX87FPUSaveSupport as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let RdSeedSupport: u64 = unsafe { ::std::mem::transmute(RdSeedSupport) };
            RdSeedSupport as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let AdxSupport: u64 = unsafe { ::std::mem::transmute(AdxSupport) };
            AdxSupport as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let IntelPrefetchSupport: u64 = unsafe { ::std::mem::transmute(IntelPrefetchSupport) };
            IntelPrefetchSupport as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let SmapSupport: u64 = unsafe { ::std::mem::transmute(SmapSupport) };
            SmapSupport as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let HleSupport: u64 = unsafe { ::std::mem::transmute(HleSupport) };
            HleSupport as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let RtmSupport: u64 = unsafe { ::std::mem::transmute(RtmSupport) };
            RtmSupport as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let RdtscpSupport: u64 = unsafe { ::std::mem::transmute(RdtscpSupport) };
            RdtscpSupport as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let ClflushoptSupport: u64 = unsafe { ::std::mem::transmute(ClflushoptSupport) };
            ClflushoptSupport as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let ClwbSupport: u64 = unsafe { ::std::mem::transmute(ClwbSupport) };
            ClwbSupport as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let ShaSupport: u64 = unsafe { ::std::mem::transmute(ShaSupport) };
            ShaSupport as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let X87PointersSavedSupport: u64 =
                unsafe { ::std::mem::transmute(X87PointersSavedSupport) };
            X87PointersSavedSupport as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let InvpcidSupport: u64 = unsafe { ::std::mem::transmute(InvpcidSupport) };
            InvpcidSupport as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let IbrsSupport: u64 = unsafe { ::std::mem::transmute(IbrsSupport) };
            IbrsSupport as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let StibpSupport: u64 = unsafe { ::std::mem::transmute(StibpSupport) };
            StibpSupport as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let IbpbSupport: u64 = unsafe { ::std::mem::transmute(IbpbSupport) };
            IbpbSupport as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let SsbdSupport: u64 = unsafe { ::std::mem::transmute(SsbdSupport) };
            SsbdSupport as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let FastShortRepMovSupport: u64 =
                unsafe { ::std::mem::transmute(FastShortRepMovSupport) };
            FastShortRepMovSupport as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let Reserved3: u64 = unsafe { ::std::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let RdclNo: u64 = unsafe { ::std::mem::transmute(RdclNo) };
            RdclNo as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let IbrsAllSupport: u64 = unsafe { ::std::mem::transmute(IbrsAllSupport) };
            IbrsAllSupport as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let Reserved4: u64 = unsafe { ::std::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let SsbNo: u64 = unsafe { ::std::mem::transmute(SsbNo) };
            SsbNo as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let RsbANo: u64 = unsafe { ::std::mem::transmute(RsbANo) };
            RsbANo as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Reserved5: u64 = unsafe { ::std::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHV_PROCESSOR_XSAVE_FEATURES {
    pub __bindgen_anon_1: _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
}
impl _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn XsaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AvxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AvxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MpxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MpxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512DQSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512DQSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512CDSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512CDSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BWSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BWSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VLSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VLSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveCompSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveCompSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveSupervisorSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupervisorSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xcr1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xcr1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BitalgSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BitalgSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512IfmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512IfmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmiSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmiSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VnniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VnniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GfniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_GfniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VaesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VaesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VPopcntdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VPopcntdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VpclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VpclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 41u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 41u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XsaveSupport: UINT64,
        XsaveoptSupport: UINT64,
        AvxSupport: UINT64,
        Avx2Support: UINT64,
        FmaSupport: UINT64,
        MpxSupport: UINT64,
        Avx512Support: UINT64,
        Avx512DQSupport: UINT64,
        Avx512CDSupport: UINT64,
        Avx512BWSupport: UINT64,
        Avx512VLSupport: UINT64,
        XsaveCompSupport: UINT64,
        XsaveSupervisorSupport: UINT64,
        Xcr1Support: UINT64,
        Avx512BitalgSupport: UINT64,
        Avx512IfmaSupport: UINT64,
        Avx512VBmiSupport: UINT64,
        Avx512VBmi2Support: UINT64,
        Avx512VnniSupport: UINT64,
        GfniSupport: UINT64,
        VaesSupport: UINT64,
        Avx512VPopcntdqSupport: UINT64,
        VpclmulqdqSupport: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XsaveSupport: u64 = unsafe { ::std::mem::transmute(XsaveSupport) };
            XsaveSupport as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XsaveoptSupport: u64 = unsafe { ::std::mem::transmute(XsaveoptSupport) };
            XsaveoptSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AvxSupport: u64 = unsafe { ::std::mem::transmute(AvxSupport) };
            AvxSupport as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Avx2Support: u64 = unsafe { ::std::mem::transmute(Avx2Support) };
            Avx2Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FmaSupport: u64 = unsafe { ::std::mem::transmute(FmaSupport) };
            FmaSupport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MpxSupport: u64 = unsafe { ::std::mem::transmute(MpxSupport) };
            MpxSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Avx512Support: u64 = unsafe { ::std::mem::transmute(Avx512Support) };
            Avx512Support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Avx512DQSupport: u64 = unsafe { ::std::mem::transmute(Avx512DQSupport) };
            Avx512DQSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Avx512CDSupport: u64 = unsafe { ::std::mem::transmute(Avx512CDSupport) };
            Avx512CDSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Avx512BWSupport: u64 = unsafe { ::std::mem::transmute(Avx512BWSupport) };
            Avx512BWSupport as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Avx512VLSupport: u64 = unsafe { ::std::mem::transmute(Avx512VLSupport) };
            Avx512VLSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let XsaveCompSupport: u64 = unsafe { ::std::mem::transmute(XsaveCompSupport) };
            XsaveCompSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let XsaveSupervisorSupport: u64 =
                unsafe { ::std::mem::transmute(XsaveSupervisorSupport) };
            XsaveSupervisorSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Xcr1Support: u64 = unsafe { ::std::mem::transmute(Xcr1Support) };
            Xcr1Support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Avx512BitalgSupport: u64 = unsafe { ::std::mem::transmute(Avx512BitalgSupport) };
            Avx512BitalgSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Avx512IfmaSupport: u64 = unsafe { ::std::mem::transmute(Avx512IfmaSupport) };
            Avx512IfmaSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Avx512VBmiSupport: u64 = unsafe { ::std::mem::transmute(Avx512VBmiSupport) };
            Avx512VBmiSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Avx512VBmi2Support: u64 = unsafe { ::std::mem::transmute(Avx512VBmi2Support) };
            Avx512VBmi2Support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Avx512VnniSupport: u64 = unsafe { ::std::mem::transmute(Avx512VnniSupport) };
            Avx512VnniSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let GfniSupport: u64 = unsafe { ::std::mem::transmute(GfniSupport) };
            GfniSupport as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let VaesSupport: u64 = unsafe { ::std::mem::transmute(VaesSupport) };
            VaesSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Avx512VPopcntdqSupport: u64 =
                unsafe { ::std::mem::transmute(Avx512VPopcntdqSupport) };
            Avx512VPopcntdqSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let VpclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(VpclmulqdqSupport) };
            VpclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 41u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_PROCESSOR_XSAVE_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub type WHV_PROCESSOR_XSAVE_FEATURES = _WHV_PROCESSOR_XSAVE_FEATURES;
pub type PWHV_PROCESSOR_XSAVE_FEATURES = *mut _WHV_PROCESSOR_XSAVE_FEATURES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY {
    pub HypervisorPresent: BOOL,
    pub Features: WHV_CAPABILITY_FEATURES,
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorVendor: WHV_PROCESSOR_VENDOR,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ExceptionExitBitmap: UINT64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).HypervisorPresent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(HypervisorPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).Features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(Features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExtendedVmExits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorVendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorXsaveFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorClFlushSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExceptionExitBitmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
}
pub type WHV_PARTITION_HANDLE = *mut VOID;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExtendedVmExits:
    WHV_PARTITION_PROPERTY_CODE = 1;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExceptionExitBitmap:
    WHV_PARTITION_PROPERTY_CODE = 2;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeSeparateSecurityDomain:
    WHV_PARTITION_PROPERTY_CODE = 3;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4097;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorClFlushSize:
    WHV_PARTITION_PROPERTY_CODE = 4098;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidExitList:
    WHV_PARTITION_PROPERTY_CODE = 4099;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidResultList:
    WHV_PARTITION_PROPERTY_CODE = 4100;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeLocalApicEmulationMode:
    WHV_PARTITION_PROPERTY_CODE = 4101;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorXsaveFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4102;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorCount:
    WHV_PARTITION_PROPERTY_CODE = 8191;
pub type WHV_PARTITION_PROPERTY_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_CPUID_RESULT {
    pub Function: UINT32,
    pub Reserved: [UINT32; 3usize],
    pub Eax: UINT32,
    pub Ebx: UINT32,
    pub Ecx: UINT32,
    pub Edx: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_RESULT>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Eax as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ebx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ecx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Edx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Edx)
        )
    );
}
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDivideErrorFault: WHV_EXCEPTION_TYPE = 0;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDebugTrapOrFault: WHV_EXCEPTION_TYPE = 1;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBreakpointTrap: WHV_EXCEPTION_TYPE = 3;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeOverflowTrap: WHV_EXCEPTION_TYPE = 4;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBoundRangeFault: WHV_EXCEPTION_TYPE = 5;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidOpcodeFault: WHV_EXCEPTION_TYPE = 6;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDeviceNotAvailableFault: WHV_EXCEPTION_TYPE = 7;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDoubleFaultAbort: WHV_EXCEPTION_TYPE = 8;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidTaskStateSegmentFault: WHV_EXCEPTION_TYPE =
    10;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSegmentNotPresentFault: WHV_EXCEPTION_TYPE = 11;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeStackFault: WHV_EXCEPTION_TYPE = 12;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeGeneralProtectionFault: WHV_EXCEPTION_TYPE = 13;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypePageFault: WHV_EXCEPTION_TYPE = 14;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeFloatingPointErrorFault: WHV_EXCEPTION_TYPE = 16;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeAlignmentCheckFault: WHV_EXCEPTION_TYPE = 17;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeMachineCheckAbort: WHV_EXCEPTION_TYPE = 18;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSimdFloatingPointFault: WHV_EXCEPTION_TYPE = 19;
pub type WHV_EXCEPTION_TYPE = i32;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeNone:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 0;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeXApic:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 1;
pub type WHV_X64_LOCAL_APIC_EMULATION_MODE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PARTITION_PROPERTY {
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ProcessorCount: UINT32,
    pub CpuidExitList: [UINT32; 1usize],
    pub CpuidResultList: [WHV_X64_CPUID_RESULT; 1usize],
    pub ExceptionExitBitmap: UINT64,
    pub LocalApicEmulationMode: WHV_X64_LOCAL_APIC_EMULATION_MODE,
    pub SeparateSecurityDomain: BOOL,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_PROPERTY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_PROPERTY>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_PROPERTY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExtendedVmExits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorXsaveFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorClFlushSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidExitList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidExitList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidResultList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidResultList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExceptionExitBitmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).LocalApicEmulationMode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(LocalApicEmulationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).SeparateSecurityDomain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(SeparateSecurityDomain)
        )
    );
}
pub type WHV_GUEST_PHYSICAL_ADDRESS = UINT64;
pub type WHV_GUEST_VIRTUAL_ADDRESS = UINT64;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagNone: WHV_MAP_GPA_RANGE_FLAGS = 0;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagRead: WHV_MAP_GPA_RANGE_FLAGS = 1;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagWrite: WHV_MAP_GPA_RANGE_FLAGS = 2;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagExecute: WHV_MAP_GPA_RANGE_FLAGS = 4;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagTrackDirtyPages: WHV_MAP_GPA_RANGE_FLAGS = 8;
pub type WHV_MAP_GPA_RANGE_FLAGS = i32;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagNone: WHV_TRANSLATE_GVA_FLAGS = 0;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateRead: WHV_TRANSLATE_GVA_FLAGS = 1;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateWrite: WHV_TRANSLATE_GVA_FLAGS = 2;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateExecute: WHV_TRANSLATE_GVA_FLAGS = 4;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagPrivilegeExempt: WHV_TRANSLATE_GVA_FLAGS = 8;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagSetPageTableBits: WHV_TRANSLATE_GVA_FLAGS = 16;
pub type WHV_TRANSLATE_GVA_FLAGS = i32;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultSuccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 0;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPageNotPresent:
    WHV_TRANSLATE_GVA_RESULT_CODE = 1;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPrivilegeViolation:
    WHV_TRANSLATE_GVA_RESULT_CODE = 2;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultInvalidPageTableFlags:
    WHV_TRANSLATE_GVA_RESULT_CODE = 3;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaUnmapped:
    WHV_TRANSLATE_GVA_RESULT_CODE = 4;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoReadAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 5;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoWriteAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 6;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaIllegalOverlayAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 7;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultIntercept:
    WHV_TRANSLATE_GVA_RESULT_CODE = 8;
pub type WHV_TRANSLATE_GVA_RESULT_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_TRANSLATE_GVA_RESULT {
    pub ResultCode: WHV_TRANSLATE_GVA_RESULT_CODE,
    pub Reserved: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_TRANSLATE_GVA_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_TRANSLATE_GVA_RESULT>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_TRANSLATE_GVA_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).ResultCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
}
pub const WHV_REGISTER_NAME_WHvX64RegisterRax: WHV_REGISTER_NAME = 0;
pub const WHV_REGISTER_NAME_WHvX64RegisterRcx: WHV_REGISTER_NAME = 1;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdx: WHV_REGISTER_NAME = 2;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbx: WHV_REGISTER_NAME = 3;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsp: WHV_REGISTER_NAME = 4;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbp: WHV_REGISTER_NAME = 5;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsi: WHV_REGISTER_NAME = 6;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdi: WHV_REGISTER_NAME = 7;
pub const WHV_REGISTER_NAME_WHvX64RegisterR8: WHV_REGISTER_NAME = 8;
pub const WHV_REGISTER_NAME_WHvX64RegisterR9: WHV_REGISTER_NAME = 9;
pub const WHV_REGISTER_NAME_WHvX64RegisterR10: WHV_REGISTER_NAME = 10;
pub const WHV_REGISTER_NAME_WHvX64RegisterR11: WHV_REGISTER_NAME = 11;
pub const WHV_REGISTER_NAME_WHvX64RegisterR12: WHV_REGISTER_NAME = 12;
pub const WHV_REGISTER_NAME_WHvX64RegisterR13: WHV_REGISTER_NAME = 13;
pub const WHV_REGISTER_NAME_WHvX64RegisterR14: WHV_REGISTER_NAME = 14;
pub const WHV_REGISTER_NAME_WHvX64RegisterR15: WHV_REGISTER_NAME = 15;
pub const WHV_REGISTER_NAME_WHvX64RegisterRip: WHV_REGISTER_NAME = 16;
pub const WHV_REGISTER_NAME_WHvX64RegisterRflags: WHV_REGISTER_NAME = 17;
pub const WHV_REGISTER_NAME_WHvX64RegisterEs: WHV_REGISTER_NAME = 18;
pub const WHV_REGISTER_NAME_WHvX64RegisterCs: WHV_REGISTER_NAME = 19;
pub const WHV_REGISTER_NAME_WHvX64RegisterSs: WHV_REGISTER_NAME = 20;
pub const WHV_REGISTER_NAME_WHvX64RegisterDs: WHV_REGISTER_NAME = 21;
pub const WHV_REGISTER_NAME_WHvX64RegisterFs: WHV_REGISTER_NAME = 22;
pub const WHV_REGISTER_NAME_WHvX64RegisterGs: WHV_REGISTER_NAME = 23;
pub const WHV_REGISTER_NAME_WHvX64RegisterLdtr: WHV_REGISTER_NAME = 24;
pub const WHV_REGISTER_NAME_WHvX64RegisterTr: WHV_REGISTER_NAME = 25;
pub const WHV_REGISTER_NAME_WHvX64RegisterIdtr: WHV_REGISTER_NAME = 26;
pub const WHV_REGISTER_NAME_WHvX64RegisterGdtr: WHV_REGISTER_NAME = 27;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr0: WHV_REGISTER_NAME = 28;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr2: WHV_REGISTER_NAME = 29;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr3: WHV_REGISTER_NAME = 30;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr4: WHV_REGISTER_NAME = 31;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr8: WHV_REGISTER_NAME = 32;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr0: WHV_REGISTER_NAME = 33;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr1: WHV_REGISTER_NAME = 34;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr2: WHV_REGISTER_NAME = 35;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr3: WHV_REGISTER_NAME = 36;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr6: WHV_REGISTER_NAME = 37;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr7: WHV_REGISTER_NAME = 38;
pub const WHV_REGISTER_NAME_WHvX64RegisterXCr0: WHV_REGISTER_NAME = 39;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm0: WHV_REGISTER_NAME = 4096;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm1: WHV_REGISTER_NAME = 4097;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm2: WHV_REGISTER_NAME = 4098;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm3: WHV_REGISTER_NAME = 4099;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm4: WHV_REGISTER_NAME = 4100;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm5: WHV_REGISTER_NAME = 4101;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm6: WHV_REGISTER_NAME = 4102;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm7: WHV_REGISTER_NAME = 4103;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm8: WHV_REGISTER_NAME = 4104;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm9: WHV_REGISTER_NAME = 4105;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm10: WHV_REGISTER_NAME = 4106;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm11: WHV_REGISTER_NAME = 4107;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm12: WHV_REGISTER_NAME = 4108;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm13: WHV_REGISTER_NAME = 4109;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm14: WHV_REGISTER_NAME = 4110;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm15: WHV_REGISTER_NAME = 4111;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx0: WHV_REGISTER_NAME = 4112;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx1: WHV_REGISTER_NAME = 4113;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx2: WHV_REGISTER_NAME = 4114;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx3: WHV_REGISTER_NAME = 4115;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx4: WHV_REGISTER_NAME = 4116;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx5: WHV_REGISTER_NAME = 4117;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx6: WHV_REGISTER_NAME = 4118;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx7: WHV_REGISTER_NAME = 4119;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpControlStatus: WHV_REGISTER_NAME = 4120;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmmControlStatus: WHV_REGISTER_NAME = 4121;
pub const WHV_REGISTER_NAME_WHvX64RegisterTsc: WHV_REGISTER_NAME = 8192;
pub const WHV_REGISTER_NAME_WHvX64RegisterEfer: WHV_REGISTER_NAME = 8193;
pub const WHV_REGISTER_NAME_WHvX64RegisterKernelGsBase: WHV_REGISTER_NAME = 8194;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicBase: WHV_REGISTER_NAME = 8195;
pub const WHV_REGISTER_NAME_WHvX64RegisterPat: WHV_REGISTER_NAME = 8196;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterCs: WHV_REGISTER_NAME = 8197;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEip: WHV_REGISTER_NAME = 8198;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEsp: WHV_REGISTER_NAME = 8199;
pub const WHV_REGISTER_NAME_WHvX64RegisterStar: WHV_REGISTER_NAME = 8200;
pub const WHV_REGISTER_NAME_WHvX64RegisterLstar: WHV_REGISTER_NAME = 8201;
pub const WHV_REGISTER_NAME_WHvX64RegisterCstar: WHV_REGISTER_NAME = 8202;
pub const WHV_REGISTER_NAME_WHvX64RegisterSfmask: WHV_REGISTER_NAME = 8203;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrCap: WHV_REGISTER_NAME = 8205;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrDefType: WHV_REGISTER_NAME = 8206;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase0: WHV_REGISTER_NAME = 8208;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase1: WHV_REGISTER_NAME = 8209;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase2: WHV_REGISTER_NAME = 8210;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase3: WHV_REGISTER_NAME = 8211;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase4: WHV_REGISTER_NAME = 8212;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase5: WHV_REGISTER_NAME = 8213;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase6: WHV_REGISTER_NAME = 8214;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase7: WHV_REGISTER_NAME = 8215;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase8: WHV_REGISTER_NAME = 8216;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase9: WHV_REGISTER_NAME = 8217;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseA: WHV_REGISTER_NAME = 8218;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseB: WHV_REGISTER_NAME = 8219;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseC: WHV_REGISTER_NAME = 8220;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseD: WHV_REGISTER_NAME = 8221;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseE: WHV_REGISTER_NAME = 8222;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseF: WHV_REGISTER_NAME = 8223;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask0: WHV_REGISTER_NAME = 8256;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask1: WHV_REGISTER_NAME = 8257;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask2: WHV_REGISTER_NAME = 8258;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask3: WHV_REGISTER_NAME = 8259;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask4: WHV_REGISTER_NAME = 8260;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask5: WHV_REGISTER_NAME = 8261;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask6: WHV_REGISTER_NAME = 8262;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask7: WHV_REGISTER_NAME = 8263;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask8: WHV_REGISTER_NAME = 8264;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask9: WHV_REGISTER_NAME = 8265;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskA: WHV_REGISTER_NAME = 8266;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskB: WHV_REGISTER_NAME = 8267;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskC: WHV_REGISTER_NAME = 8268;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskD: WHV_REGISTER_NAME = 8269;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskE: WHV_REGISTER_NAME = 8270;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskF: WHV_REGISTER_NAME = 8271;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix64k00000: WHV_REGISTER_NAME = 8304;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16k80000: WHV_REGISTER_NAME = 8305;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16kA0000: WHV_REGISTER_NAME = 8306;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC0000: WHV_REGISTER_NAME = 8307;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC8000: WHV_REGISTER_NAME = 8308;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD0000: WHV_REGISTER_NAME = 8309;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD8000: WHV_REGISTER_NAME = 8310;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE0000: WHV_REGISTER_NAME = 8311;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE8000: WHV_REGISTER_NAME = 8312;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF0000: WHV_REGISTER_NAME = 8313;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF8000: WHV_REGISTER_NAME = 8314;
pub const WHV_REGISTER_NAME_WHvX64RegisterTscAux: WHV_REGISTER_NAME = 8315;
pub const WHV_REGISTER_NAME_WHvX64RegisterSpecCtrl: WHV_REGISTER_NAME = 8324;
pub const WHV_REGISTER_NAME_WHvX64RegisterPredCmd: WHV_REGISTER_NAME = 8325;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicId: WHV_REGISTER_NAME = 12290;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicVersion: WHV_REGISTER_NAME = 12291;
pub const WHV_REGISTER_NAME_WHvRegisterPendingInterruption: WHV_REGISTER_NAME = -2147483648;
pub const WHV_REGISTER_NAME_WHvRegisterInterruptState: WHV_REGISTER_NAME = -2147483647;
pub const WHV_REGISTER_NAME_WHvRegisterPendingEvent: WHV_REGISTER_NAME = -2147483646;
pub const WHV_REGISTER_NAME_WHvX64RegisterDeliverabilityNotifications: WHV_REGISTER_NAME =
    -2147483644;
pub const WHV_REGISTER_NAME_WHvRegisterInternalActivityState: WHV_REGISTER_NAME = -2147483643;
pub type WHV_REGISTER_NAME = i32;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_UINT128 {
    pub __bindgen_anon_1: WHV_UINT128__bindgen_ty_1,
    pub Dword: [UINT32; 4usize],
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_UINT128__bindgen_ty_1 {
    pub Low64: UINT64,
    pub High64: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_UINT128__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_UINT128__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).Low64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(Low64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).High64 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(High64)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_UINT128() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_UINT128>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_UINT128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128>())).Dword as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128),
            "::",
            stringify!(Dword)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_FP_REGISTER__bindgen_ty_1 {
    pub Mantissa: UINT64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_REGISTER__bindgen_ty_1>())).Mantissa as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Mantissa)
        )
    );
}
impl WHV_X64_FP_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn BiasedExponent(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_BiasedExponent(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn Sign(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sign(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BiasedExponent: UINT64,
        Sign: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let BiasedExponent: u64 = unsafe { ::std::mem::transmute(BiasedExponent) };
            BiasedExponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Sign: u64 = unsafe { ::std::mem::transmute(Sign) };
            Sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_REGISTER>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_FP_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_FP_REGISTER>())).AsUINT128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub FpControl: UINT16,
    pub FpStatus: UINT16,
    pub FpTag: UINT8,
    pub Reserved: UINT8,
    pub LastFpOp: UINT16,
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRip: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpEip: UINT32,
    pub LastFpCs: UINT16,
    pub Reserved2: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpEip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpEip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpCs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpCs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved2 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRip)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpControl
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpTag
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).Reserved
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).LastFpOp
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(LastFpOp)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub XmmStatusControl: UINT32,
    pub XmmStatusControlMask: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRdp: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpDp: UINT32,
    pub LastFpDs: UINT16,
    pub Reserved: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRdp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRdp)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControlMask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControlMask)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER {
    pub Base: UINT64,
    pub Limit: UINT32,
    pub Selector: UINT16,
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_SEGMENT_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub Attributes: UINT16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SegmentType(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SegmentType(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NonSystemSegment(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonSystemSegment(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DescriptorPrivilegeLevel(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DescriptorPrivilegeLevel(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Present(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Long(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Long(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Default(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SegmentType: UINT16,
        NonSystemSegment: UINT16,
        DescriptorPrivilegeLevel: UINT16,
        Present: UINT16,
        Reserved: UINT16,
        Available: UINT16,
        Long: UINT16,
        Default: UINT16,
        Granularity: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SegmentType: u16 = unsafe { ::std::mem::transmute(SegmentType) };
            SegmentType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NonSystemSegment: u16 = unsafe { ::std::mem::transmute(NonSystemSegment) };
            NonSystemSegment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let DescriptorPrivilegeLevel: u16 =
                unsafe { ::std::mem::transmute(DescriptorPrivilegeLevel) };
            DescriptorPrivilegeLevel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Present: u16 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Available: u16 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Long: u16 = unsafe { ::std::mem::transmute(Long) };
            Long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Default: u16 = unsafe { ::std::mem::transmute(Default) };
            Default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Granularity: u16 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>())).Attributes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Attributes)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Selector as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Selector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_TABLE_REGISTER {
    pub Pad: [UINT16; 3usize],
    pub Limit: UINT16,
    pub Base: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_TABLE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_TABLE_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_TABLE_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Limit as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_INTERRUPT_STATE_REGISTER {
    pub __bindgen_anon_1: WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptShadow(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NmiMasked(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiMasked(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptShadow: UINT64,
        NmiMasked: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptShadow: u64 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NmiMasked: u64 = unsafe { ::std::mem::transmute(NmiMasked) };
            NmiMasked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_INTERRUPT_STATE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPT_STATE_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_INTERRUPTION_REGISTER {
    pub __bindgen_anon_1: WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub ErrorCode: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>()))
                .ErrorCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptionPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionLength(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NestedEvent(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NestedEvent(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionVector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionVector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptionPending: UINT32,
        InterruptionType: UINT32,
        DeliverErrorCode: UINT32,
        InstructionLength: UINT32,
        NestedEvent: UINT32,
        Reserved: UINT32,
        InterruptionVector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptionPending: u32 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let InterruptionType: u32 = unsafe { ::std::mem::transmute(InterruptionType) };
            InterruptionType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let InstructionLength: u32 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let NestedEvent: u32 = unsafe { ::std::mem::transmute(NestedEvent) };
            NestedEvent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let InterruptionVector: u32 = unsafe { ::std::mem::transmute(InterruptionVector) };
            InterruptionVector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn NmiNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptPriority(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptPriority(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NmiNotification: UINT64,
        InterruptNotification: UINT64,
        InterruptPriority: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NmiNotification: u64 = unsafe { ::std::mem::transmute(NmiNotification) };
            NmiNotification as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InterruptNotification: u64 =
                unsafe { ::std::mem::transmute(InterruptNotification) };
            InterruptNotification as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let InterruptPriority: u64 = unsafe { ::std::mem::transmute(InterruptPriority) };
            InterruptPriority as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>())).AsUINT64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventException: WHV_X64_PENDING_EVENT_TYPE = 0;
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventExtInt: WHV_X64_PENDING_EVENT_TYPE = 5;
pub type WHV_X64_PENDING_EVENT_TYPE = i32;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXCEPTION_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>())).ErrorCode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>()))
                .ExceptionParameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
impl WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT32,
        EventType: UINT32,
        Reserved0: UINT32,
        DeliverErrorCode: UINT32,
        Reserved1: UINT32,
        Vector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u32 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u32 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Vector: u32 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXCEPTION_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXCEPTION_EVENT>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_PENDING_EXCEPTION_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXT_INT_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub Reserved2: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>())).Reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1),
            "::",
            stringify!(Reserved2)
        )
    );
}
impl WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT64,
        EventType: UINT64,
        Reserved0: UINT64,
        Vector: UINT64,
        Reserved1: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u64 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u64 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u64 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Vector: u64 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXT_INT_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXT_INT_EVENT>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_PENDING_EXT_INT_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT>())).AsUINT128 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_REGISTER_VALUE {
    pub Reg128: WHV_UINT128,
    pub Reg64: UINT64,
    pub Reg32: UINT32,
    pub Reg16: UINT16,
    pub Reg8: UINT8,
    pub Fp: WHV_X64_FP_REGISTER,
    pub FpControlStatus: WHV_X64_FP_CONTROL_STATUS_REGISTER,
    pub XmmControlStatus: WHV_X64_XMM_CONTROL_STATUS_REGISTER,
    pub Segment: WHV_X64_SEGMENT_REGISTER,
    pub Table: WHV_X64_TABLE_REGISTER,
    pub InterruptState: WHV_X64_INTERRUPT_STATE_REGISTER,
    pub PendingInterruption: WHV_X64_PENDING_INTERRUPTION_REGISTER,
    pub DeliverabilityNotifications: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER,
    pub ExceptionEvent: WHV_X64_PENDING_EXCEPTION_EVENT,
    pub ExtIntEvent: WHV_X64_PENDING_EXT_INT_EVENT,
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_WHV_REGISTER_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_REGISTER_VALUE>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_REGISTER_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_REGISTER_VALUE>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_REGISTER_VALUE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg128)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).FpControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(FpControlStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).XmmControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(XmmControlStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).InterruptState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(InterruptState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).PendingInterruption as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(PendingInterruption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).DeliverabilityNotifications as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(DeliverabilityNotifications)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExceptionEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExceptionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExtIntEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExtIntEvent)
        )
    );
}
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonNone: WHV_RUN_VP_EXIT_REASON = 0;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonMemoryAccess: WHV_RUN_VP_EXIT_REASON = 1;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64IoPortAccess: WHV_RUN_VP_EXIT_REASON = 2;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnrecoverableException: WHV_RUN_VP_EXIT_REASON =
    4;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonInvalidVpRegisterValue: WHV_RUN_VP_EXIT_REASON =
    5;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnsupportedFeature: WHV_RUN_VP_EXIT_REASON = 6;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64InterruptWindow: WHV_RUN_VP_EXIT_REASON = 7;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Halt: WHV_RUN_VP_EXIT_REASON = 8;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicEoi: WHV_RUN_VP_EXIT_REASON = 9;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64MsrAccess: WHV_RUN_VP_EXIT_REASON = 4096;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Cpuid: WHV_RUN_VP_EXIT_REASON = 4097;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonException: WHV_RUN_VP_EXIT_REASON = 4098;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonCanceled: WHV_RUN_VP_EXIT_REASON = 8193;
pub type WHV_RUN_VP_EXIT_REASON = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_VP_EXECUTION_STATE {
    pub __bindgen_anon_1: WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1,
    pub AsUINT16: UINT16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
}
impl WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    #[inline]
    pub fn Cpl(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Cpl(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Pe(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Pe(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Am(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Am(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EferLma(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EferLma(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugActive(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DebugActive(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionPending(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptShadow(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Cpl: UINT16,
        Cr0Pe: UINT16,
        Cr0Am: UINT16,
        EferLma: UINT16,
        DebugActive: UINT16,
        InterruptionPending: UINT16,
        Reserved0: UINT16,
        InterruptShadow: UINT16,
        Reserved1: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Cpl: u16 = unsafe { ::std::mem::transmute(Cpl) };
            Cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Cr0Pe: u16 = unsafe { ::std::mem::transmute(Cr0Pe) };
            Cr0Pe as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Cr0Am: u16 = unsafe { ::std::mem::transmute(Cr0Am) };
            Cr0Am as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EferLma: u16 = unsafe { ::std::mem::transmute(EferLma) };
            EferLma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DebugActive: u16 = unsafe { ::std::mem::transmute(DebugActive) };
            DebugActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let InterruptionPending: u16 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let Reserved0: u16 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InterruptShadow: u16 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved1: u16 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Size of: ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Alignment of ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_VP_EXECUTION_STATE>())).AsUINT16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE),
            "::",
            stringify!(AsUINT16)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXIT_CONTEXT {
    pub ExecutionState: WHV_X64_VP_EXECUTION_STATE,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub Reserved: UINT8,
    pub Reserved2: UINT32,
    pub Cs: WHV_X64_SEGMENT_REGISTER,
    pub Rip: UINT64,
    pub Rflags: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXIT_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXIT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).ExecutionState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExecutionState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rflags)
        )
    );
}
impl WHV_VP_EXIT_CONTEXT {
    #[inline]
    pub fn InstructionLength(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr8(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Cr8(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InstructionLength: UINT8,
        Cr8: UINT8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let InstructionLength: u8 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Cr8: u8 = unsafe { ::std::mem::transmute(Cr8) };
            Cr8 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessRead: WHV_MEMORY_ACCESS_TYPE = 0;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessWrite: WHV_MEMORY_ACCESS_TYPE = 1;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessExecute: WHV_MEMORY_ACCESS_TYPE = 2;
pub type WHV_MEMORY_ACCESS_TYPE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_MEMORY_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_MEMORY_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn AccessType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AccessType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn GpaUnmapped(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GpaUnmapped(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GvaValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GvaValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AccessType: UINT32,
        GpaUnmapped: UINT32,
        GvaValid: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let AccessType: u32 = unsafe { ::std::mem::transmute(AccessType) };
            AccessType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GpaUnmapped: u32 = unsafe { ::std::mem::transmute(GpaUnmapped) };
            GpaUnmapped as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GvaValid: u32 = unsafe { ::std::mem::transmute(GvaValid) };
            GvaValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_MEMORY_ACCESS_INFO,
    pub Gpa: WHV_GUEST_PHYSICAL_ADDRESS,
    pub Gva: WHV_GUEST_VIRTUAL_ADDRESS,
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gpa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gva as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gva)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_IO_PORT_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessSize(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AccessSize(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn StringOp(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StringOp(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RepPrefix(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RepPrefix(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        AccessSize: UINT32,
        StringOp: UINT32,
        RepPrefix: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let AccessSize: u32 = unsafe { ::std::mem::transmute(AccessSize) };
            AccessSize as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let StringOp: u32 = unsafe { ::std::mem::transmute(StringOp) };
            StringOp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RepPrefix: u32 = unsafe { ::std::mem::transmute(RepPrefix) };
            RepPrefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_X64_IO_PORT_ACCESS_INFO,
    pub PortNumber: UINT16,
    pub Reserved2: [UINT16; 3usize],
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rsi: UINT64,
    pub Rdi: UINT64,
    pub Ds: WHV_X64_SEGMENT_REGISTER,
    pub Es: WHV_X64_SEGMENT_REGISTER,
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        96usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionByteCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).AccessInfo as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).PortNumber as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(PortNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved2 as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rsi as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rdi as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Ds as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Es as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Es)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_MSR_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_CONTEXT {
    pub AccessInfo: WHV_X64_MSR_ACCESS_INFO,
    pub MsrNumber: UINT32,
    pub Rax: UINT64,
    pub Rdx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).MsrNumber as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(MsrNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rdx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_CPUID_ACCESS_CONTEXT {
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rdx: UINT64,
    pub Rbx: UINT64,
    pub DefaultResultRax: UINT64,
    pub DefaultResultRcx: UINT64,
    pub DefaultResultRdx: UINT64,
    pub DefaultResultRbx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        64usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rdx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rbx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRax as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRcx as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRdx as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRbx as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRbx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_VP_EXCEPTION_INFO {
    pub __bindgen_anon_1: WHV_VP_EXCEPTION_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    #[inline]
    pub fn ErrorCodeValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorCodeValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftwareException(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SoftwareException(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorCodeValid: UINT32,
        SoftwareException: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorCodeValid: u32 = unsafe { ::std::mem::transmute(ErrorCodeValid) };
            ErrorCodeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SoftwareException: u32 = unsafe { ::std::mem::transmute(SoftwareException) };
            SoftwareException as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXCEPTION_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXCEPTION_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub ExceptionInfo: WHV_VP_EXCEPTION_INFO,
    pub ExceptionType: UINT8,
    pub Reserved2: [UINT8; 3usize],
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved2 as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ErrorCode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionParameter as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureIntercept:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 1;
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureTaskSwitchTss:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 2;
pub type WHV_X64_UNSUPPORTED_FEATURE_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_UNSUPPORTED_FEATURE_CONTEXT {
    pub FeatureCode: WHV_X64_UNSUPPORTED_FEATURE_CODE,
    pub Reserved: UINT32,
    pub FeatureParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_UNSUPPORTED_FEATURE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).Reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureParameter
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureParameter)
        )
    );
}
pub const WHV_RUN_VP_CANCEL_REASON_WhvRunVpCancelReasonUser: WHV_RUN_VP_CANCEL_REASON = 0;
pub type WHV_RUN_VP_CANCEL_REASON = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_RUN_VP_CANCELED_CONTEXT {
    pub CancelReason: WHV_RUN_VP_CANCEL_REASON,
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_CANCELED_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_CANCELED_CONTEXT>())).CancelReason as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_CANCELED_CONTEXT),
            "::",
            stringify!(CancelReason)
        )
    );
}
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingInterrupt:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 0;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingNmi: WHV_X64_PENDING_INTERRUPTION_TYPE = 2;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingException:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 3;
pub type WHV_X64_PENDING_INTERRUPTION_TYPE = i32;
pub type PWHV_X64_PENDING_INTERRUPTION_TYPE = *mut WHV_X64_PENDING_INTERRUPTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT {
    pub DeliverableType: WHV_X64_PENDING_INTERRUPTION_TYPE,
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>())).DeliverableType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT),
            "::",
            stringify!(DeliverableType)
        )
    );
}
pub type PWHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT = *mut WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_APIC_EOI_CONTEXT {
    pub InterruptVector: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_EOI_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_EOI_CONTEXT>())).InterruptVector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_EOI_CONTEXT),
            "::",
            stringify!(InterruptVector)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_RUN_VP_EXIT_CONTEXT {
    pub ExitReason: WHV_RUN_VP_EXIT_REASON,
    pub Reserved: UINT32,
    pub VpContext: WHV_VP_EXIT_CONTEXT,
    pub __bindgen_anon_1: WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1 {
    pub MemoryAccess: WHV_MEMORY_ACCESS_CONTEXT,
    pub IoPortAccess: WHV_X64_IO_PORT_ACCESS_CONTEXT,
    pub MsrAccess: WHV_X64_MSR_ACCESS_CONTEXT,
    pub CpuidAccess: WHV_X64_CPUID_ACCESS_CONTEXT,
    pub VpException: WHV_VP_EXCEPTION_CONTEXT,
    pub InterruptWindow: WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT,
    pub UnsupportedFeature: WHV_X64_UNSUPPORTED_FEATURE_CONTEXT,
    pub CancelReason: WHV_RUN_VP_CANCELED_CONTEXT,
    pub ApicEoi: WHV_X64_APIC_EOI_CONTEXT,
    _bindgen_union_align: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MemoryAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MemoryAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).IoPortAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(IoPortAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MsrAccess as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MsrAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CpuidAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CpuidAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).VpException
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(VpException)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).InterruptWindow
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(InterruptWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).UnsupportedFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(UnsupportedFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CancelReason
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CancelReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicEoi as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicEoi)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        144usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).ExitReason as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExitReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).VpContext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(VpContext)
        )
    );
}
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeFixed: WHV_INTERRUPT_TYPE = 0;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLowestPriority: WHV_INTERRUPT_TYPE = 1;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeNmi: WHV_INTERRUPT_TYPE = 4;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeInit: WHV_INTERRUPT_TYPE = 5;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeSipi: WHV_INTERRUPT_TYPE = 6;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLocalInt1: WHV_INTERRUPT_TYPE = 9;
pub type WHV_INTERRUPT_TYPE = i32;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModePhysical:
    WHV_INTERRUPT_DESTINATION_MODE = 0;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModeLogical:
    WHV_INTERRUPT_DESTINATION_MODE = 1;
pub type WHV_INTERRUPT_DESTINATION_MODE = i32;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeEdge: WHV_INTERRUPT_TRIGGER_MODE = 0;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeLevel: WHV_INTERRUPT_TRIGGER_MODE =
    1;
pub type WHV_INTERRUPT_TRIGGER_MODE = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct WHV_INTERRUPT_CONTROL {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub Destination: UINT32,
    pub Vector: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_INTERRUPT_CONTROL() {
    assert_eq!(
        ::std::mem::size_of::<WHV_INTERRUPT_CONTROL>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_INTERRUPT_CONTROL>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Destination as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Vector as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Vector)
        )
    );
}
impl WHV_INTERRUPT_CONTROL {
    #[inline]
    pub fn Type(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DestinationMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_DestinationMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn TriggerMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_TriggerMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: UINT64,
        DestinationMode: UINT64,
        TriggerMode: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let DestinationMode: u64 = unsafe { ::std::mem::transmute(DestinationMode) };
            DestinationMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let TriggerMode: u64 = unsafe { ::std::mem::transmute(TriggerMode) };
            TriggerMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_PARTITION_COUNTER_SET_WHvPartitionCounterSetMemory: WHV_PARTITION_COUNTER_SET = 0;
pub type WHV_PARTITION_COUNTER_SET = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PARTITION_MEMORY_COUNTERS {
    pub Mapped4KPageCount: UINT64,
    pub Mapped2MPageCount: UINT64,
    pub Mapped1GPageCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_MEMORY_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped4KPageCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped4KPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped2MPageCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped2MPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped1GPageCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped1GPageCount)
        )
    );
}
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetRuntime: WHV_PROCESSOR_COUNTER_SET = 0;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetIntercepts: WHV_PROCESSOR_COUNTER_SET = 1;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetEvents: WHV_PROCESSOR_COUNTER_SET = 2;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetApic: WHV_PROCESSOR_COUNTER_SET = 3;
pub type WHV_PROCESSOR_COUNTER_SET = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_RUNTIME_COUNTERS {
    pub TotalRuntime100ns: UINT64,
    pub HypervisorRuntime100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_RUNTIME_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).TotalRuntime100ns as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(TotalRuntime100ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).HypervisorRuntime100ns
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(HypervisorRuntime100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTER {
    pub Count: UINT64,
    pub Time100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Time100ns as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Time100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTERS {
    pub PageInvalidations: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub ControlRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub IoInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub HaltInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub CpuidInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub MsrAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub OtherIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PendingInterrupts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub EmulatedInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub DebugRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PageFaultIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        176usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageInvalidations
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageInvalidations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).ControlRegisterAccesses
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(ControlRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).IoInstructions as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(IoInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).HaltInstructions
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(HaltInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).CpuidInstructions
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(CpuidInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).MsrAccesses as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(MsrAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).OtherIntercepts as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(OtherIntercepts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PendingInterrupts
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PendingInterrupts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).EmulatedInstructions
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(EmulatedInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).DebugRegisterAccesses
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(DebugRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageFaultIntercepts
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageFaultIntercepts)
        )
    );
}
pub type WHV_PROCESSOR_ACTIVITY_COUNTERS = WHV_PROCESSOR_INTERCEPT_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_EVENT_COUNTERS {
    pub PageFaultCount: UINT64,
    pub ExceptionCount: UINT64,
    pub InterruptCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_EVENT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).PageFaultCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(PageFaultCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).ExceptionCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(ExceptionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).InterruptCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(InterruptCount)
        )
    );
}
pub type WHV_PROCESSOR_GUEST_EVENT_COUNTERS = WHV_PROCESSOR_EVENT_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_APIC_COUNTERS {
    pub MmioAccessCount: UINT64,
    pub EoiAccessCount: UINT64,
    pub TprAccessCount: UINT64,
    pub SentIpiCount: UINT64,
    pub SelfIpiCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_APIC_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).MmioAccessCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(MmioAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).EoiAccessCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(EoiAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).TprAccessCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(TprAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SentIpiCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SentIpiCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SelfIpiCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SelfIpiCount)
        )
    );
}
extern "C" {
    pub fn WHvGetCapability(
        CapabilityCode: WHV_CAPABILITY_CODE,
        CapabilityBuffer: *mut VOID,
        CapabilityBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
#[link(name = "winhvplatform")]
extern "C" {
    pub fn WHvCreatePartition(Partition: *mut WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvSetupPartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvDeletePartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvGetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *mut VOID,
        PropertyBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *const VOID,
        PropertyBufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSuspendPartitionTime(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvResumePartitionTime(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvMapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        SourceAddress: *mut VOID,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
        Flags: WHV_MAP_GPA_RANGE_FLAGS,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvUnmapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvTranslateGva(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Gva: WHV_GUEST_VIRTUAL_ADDRESS,
        TranslateFlags: WHV_TRANSLATE_GVA_FLAGS,
        TranslationResult: *mut WHV_TRANSLATE_GVA_RESULT,
        Gpa: *mut WHV_GUEST_PHYSICAL_ADDRESS,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvCreateVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvDeleteVirtualProcessor(Partition: WHV_PARTITION_HANDLE, VpIndex: UINT32) -> HRESULT;
}
extern "C" {
    pub fn WHvRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        ExitContext: *mut VOID,
        ExitContextSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvCancelRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *mut WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *const WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *mut VOID,
        StateSize: UINT32,
        WrittenSize: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *const VOID,
        StateSize: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvRequestInterrupt(
        Partition: WHV_PARTITION_HANDLE,
        Interrupt: *const WHV_INTERRUPT_CONTROL,
        InterruptControlSize: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *mut VOID,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *const VOID,
        BufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvQueryGpaRangeDirtyBitmap(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        RangeSizeInBytes: UINT64,
        Bitmap: *mut UINT64,
        BitmapSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetPartitionCounters(
        Partition: WHV_PARTITION_HANDLE,
        CounterSet: WHV_PARTITION_COUNTER_SET,
        Buffer: *mut VOID,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorCounters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        CounterSet: WHV_PROCESSOR_COUNTER_SET,
        Buffer: *mut VOID,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
